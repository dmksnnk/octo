// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"
	"time"

	"github.com/dmksnnk/octo/internal"
	mock "github.com/stretchr/testify/mock"
)

// NewMockService creates a new instance of MockService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockService(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockService {
	mock := &MockService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockService is an autogenerated mock type for the Service type
type MockService struct {
	mock.Mock
}

type MockService_Expecter struct {
	mock *mock.Mock
}

func (_m *MockService) EXPECT() *MockService_Expecter {
	return &MockService_Expecter{mock: &_m.Mock}
}

// Availabilities provides a mock function for the type MockService
func (_mock *MockService) Availabilities(ctx context.Context, productID int, localDateStart time.Time, localDateEnd time.Time, capability internal.CapabilityRequest) ([]internal.Availability, error) {
	ret := _mock.Called(ctx, productID, localDateStart, localDateEnd, capability)

	if len(ret) == 0 {
		panic("no return value specified for Availabilities")
	}

	var r0 []internal.Availability
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, time.Time, time.Time, internal.CapabilityRequest) ([]internal.Availability, error)); ok {
		return returnFunc(ctx, productID, localDateStart, localDateEnd, capability)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, time.Time, time.Time, internal.CapabilityRequest) []internal.Availability); ok {
		r0 = returnFunc(ctx, productID, localDateStart, localDateEnd, capability)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]internal.Availability)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int, time.Time, time.Time, internal.CapabilityRequest) error); ok {
		r1 = returnFunc(ctx, productID, localDateStart, localDateEnd, capability)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockService_Availabilities_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Availabilities'
type MockService_Availabilities_Call struct {
	*mock.Call
}

// Availabilities is a helper method to define mock.On call
//   - ctx
//   - productID
//   - localDateStart
//   - localDateEnd
//   - capability
func (_e *MockService_Expecter) Availabilities(ctx interface{}, productID interface{}, localDateStart interface{}, localDateEnd interface{}, capability interface{}) *MockService_Availabilities_Call {
	return &MockService_Availabilities_Call{Call: _e.mock.On("Availabilities", ctx, productID, localDateStart, localDateEnd, capability)}
}

func (_c *MockService_Availabilities_Call) Run(run func(ctx context.Context, productID int, localDateStart time.Time, localDateEnd time.Time, capability internal.CapabilityRequest)) *MockService_Availabilities_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(time.Time), args[3].(time.Time), args[4].(internal.CapabilityRequest))
	})
	return _c
}

func (_c *MockService_Availabilities_Call) Return(availabilitys []internal.Availability, err error) *MockService_Availabilities_Call {
	_c.Call.Return(availabilitys, err)
	return _c
}

func (_c *MockService_Availabilities_Call) RunAndReturn(run func(ctx context.Context, productID int, localDateStart time.Time, localDateEnd time.Time, capability internal.CapabilityRequest) ([]internal.Availability, error)) *MockService_Availabilities_Call {
	_c.Call.Return(run)
	return _c
}

// Availability provides a mock function for the type MockService
func (_mock *MockService) Availability(ctx context.Context, productID int, localDate time.Time, capability internal.CapabilityRequest) (internal.Availability, error) {
	ret := _mock.Called(ctx, productID, localDate, capability)

	if len(ret) == 0 {
		panic("no return value specified for Availability")
	}

	var r0 internal.Availability
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, time.Time, internal.CapabilityRequest) (internal.Availability, error)); ok {
		return returnFunc(ctx, productID, localDate, capability)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, time.Time, internal.CapabilityRequest) internal.Availability); ok {
		r0 = returnFunc(ctx, productID, localDate, capability)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(internal.Availability)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int, time.Time, internal.CapabilityRequest) error); ok {
		r1 = returnFunc(ctx, productID, localDate, capability)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockService_Availability_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Availability'
type MockService_Availability_Call struct {
	*mock.Call
}

// Availability is a helper method to define mock.On call
//   - ctx
//   - productID
//   - localDate
//   - capability
func (_e *MockService_Expecter) Availability(ctx interface{}, productID interface{}, localDate interface{}, capability interface{}) *MockService_Availability_Call {
	return &MockService_Availability_Call{Call: _e.mock.On("Availability", ctx, productID, localDate, capability)}
}

func (_c *MockService_Availability_Call) Run(run func(ctx context.Context, productID int, localDate time.Time, capability internal.CapabilityRequest)) *MockService_Availability_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(time.Time), args[3].(internal.CapabilityRequest))
	})
	return _c
}

func (_c *MockService_Availability_Call) Return(availability internal.Availability, err error) *MockService_Availability_Call {
	_c.Call.Return(availability, err)
	return _c
}

func (_c *MockService_Availability_Call) RunAndReturn(run func(ctx context.Context, productID int, localDate time.Time, capability internal.CapabilityRequest) (internal.Availability, error)) *MockService_Availability_Call {
	_c.Call.Return(run)
	return _c
}

// Booking provides a mock function for the type MockService
func (_mock *MockService) Booking(ctx context.Context, id int, userID int, capability internal.CapabilityRequest) (internal.Booking, error) {
	ret := _mock.Called(ctx, id, userID, capability)

	if len(ret) == 0 {
		panic("no return value specified for Booking")
	}

	var r0 internal.Booking
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, int, internal.CapabilityRequest) (internal.Booking, error)); ok {
		return returnFunc(ctx, id, userID, capability)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, int, internal.CapabilityRequest) internal.Booking); ok {
		r0 = returnFunc(ctx, id, userID, capability)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(internal.Booking)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int, int, internal.CapabilityRequest) error); ok {
		r1 = returnFunc(ctx, id, userID, capability)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockService_Booking_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Booking'
type MockService_Booking_Call struct {
	*mock.Call
}

// Booking is a helper method to define mock.On call
//   - ctx
//   - id
//   - userID
//   - capability
func (_e *MockService_Expecter) Booking(ctx interface{}, id interface{}, userID interface{}, capability interface{}) *MockService_Booking_Call {
	return &MockService_Booking_Call{Call: _e.mock.On("Booking", ctx, id, userID, capability)}
}

func (_c *MockService_Booking_Call) Run(run func(ctx context.Context, id int, userID int, capability internal.CapabilityRequest)) *MockService_Booking_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int), args[3].(internal.CapabilityRequest))
	})
	return _c
}

func (_c *MockService_Booking_Call) Return(booking internal.Booking, err error) *MockService_Booking_Call {
	_c.Call.Return(booking, err)
	return _c
}

func (_c *MockService_Booking_Call) RunAndReturn(run func(ctx context.Context, id int, userID int, capability internal.CapabilityRequest) (internal.Booking, error)) *MockService_Booking_Call {
	_c.Call.Return(run)
	return _c
}

// ConfirmBooking provides a mock function for the type MockService
func (_mock *MockService) ConfirmBooking(ctx context.Context, id int, userID int) error {
	ret := _mock.Called(ctx, id, userID)

	if len(ret) == 0 {
		panic("no return value specified for ConfirmBooking")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, int) error); ok {
		r0 = returnFunc(ctx, id, userID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockService_ConfirmBooking_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConfirmBooking'
type MockService_ConfirmBooking_Call struct {
	*mock.Call
}

// ConfirmBooking is a helper method to define mock.On call
//   - ctx
//   - id
//   - userID
func (_e *MockService_Expecter) ConfirmBooking(ctx interface{}, id interface{}, userID interface{}) *MockService_ConfirmBooking_Call {
	return &MockService_ConfirmBooking_Call{Call: _e.mock.On("ConfirmBooking", ctx, id, userID)}
}

func (_c *MockService_ConfirmBooking_Call) Run(run func(ctx context.Context, id int, userID int)) *MockService_ConfirmBooking_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int))
	})
	return _c
}

func (_c *MockService_ConfirmBooking_Call) Return(err error) *MockService_ConfirmBooking_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockService_ConfirmBooking_Call) RunAndReturn(run func(ctx context.Context, id int, userID int) error) *MockService_ConfirmBooking_Call {
	_c.Call.Return(run)
	return _c
}

// CreateBooking provides a mock function for the type MockService
func (_mock *MockService) CreateBooking(ctx context.Context, params internal.CreateBookingRequest) (int, error) {
	ret := _mock.Called(ctx, params)

	if len(ret) == 0 {
		panic("no return value specified for CreateBooking")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, internal.CreateBookingRequest) (int, error)); ok {
		return returnFunc(ctx, params)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, internal.CreateBookingRequest) int); ok {
		r0 = returnFunc(ctx, params)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, internal.CreateBookingRequest) error); ok {
		r1 = returnFunc(ctx, params)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockService_CreateBooking_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBooking'
type MockService_CreateBooking_Call struct {
	*mock.Call
}

// CreateBooking is a helper method to define mock.On call
//   - ctx
//   - params
func (_e *MockService_Expecter) CreateBooking(ctx interface{}, params interface{}) *MockService_CreateBooking_Call {
	return &MockService_CreateBooking_Call{Call: _e.mock.On("CreateBooking", ctx, params)}
}

func (_c *MockService_CreateBooking_Call) Run(run func(ctx context.Context, params internal.CreateBookingRequest)) *MockService_CreateBooking_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(internal.CreateBookingRequest))
	})
	return _c
}

func (_c *MockService_CreateBooking_Call) Return(n int, err error) *MockService_CreateBooking_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockService_CreateBooking_Call) RunAndReturn(run func(ctx context.Context, params internal.CreateBookingRequest) (int, error)) *MockService_CreateBooking_Call {
	_c.Call.Return(run)
	return _c
}

// Product provides a mock function for the type MockService
func (_mock *MockService) Product(ctx context.Context, id int, capability internal.CapabilityRequest) (internal.Product, error) {
	ret := _mock.Called(ctx, id, capability)

	if len(ret) == 0 {
		panic("no return value specified for Product")
	}

	var r0 internal.Product
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, internal.CapabilityRequest) (internal.Product, error)); ok {
		return returnFunc(ctx, id, capability)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, internal.CapabilityRequest) internal.Product); ok {
		r0 = returnFunc(ctx, id, capability)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(internal.Product)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int, internal.CapabilityRequest) error); ok {
		r1 = returnFunc(ctx, id, capability)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockService_Product_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Product'
type MockService_Product_Call struct {
	*mock.Call
}

// Product is a helper method to define mock.On call
//   - ctx
//   - id
//   - capability
func (_e *MockService_Expecter) Product(ctx interface{}, id interface{}, capability interface{}) *MockService_Product_Call {
	return &MockService_Product_Call{Call: _e.mock.On("Product", ctx, id, capability)}
}

func (_c *MockService_Product_Call) Run(run func(ctx context.Context, id int, capability internal.CapabilityRequest)) *MockService_Product_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(internal.CapabilityRequest))
	})
	return _c
}

func (_c *MockService_Product_Call) Return(product internal.Product, err error) *MockService_Product_Call {
	_c.Call.Return(product, err)
	return _c
}

func (_c *MockService_Product_Call) RunAndReturn(run func(ctx context.Context, id int, capability internal.CapabilityRequest) (internal.Product, error)) *MockService_Product_Call {
	_c.Call.Return(run)
	return _c
}

// Products provides a mock function for the type MockService
func (_mock *MockService) Products(ctx context.Context, capability internal.CapabilityRequest) ([]internal.Product, error) {
	ret := _mock.Called(ctx, capability)

	if len(ret) == 0 {
		panic("no return value specified for Products")
	}

	var r0 []internal.Product
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, internal.CapabilityRequest) ([]internal.Product, error)); ok {
		return returnFunc(ctx, capability)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, internal.CapabilityRequest) []internal.Product); ok {
		r0 = returnFunc(ctx, capability)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]internal.Product)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, internal.CapabilityRequest) error); ok {
		r1 = returnFunc(ctx, capability)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockService_Products_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Products'
type MockService_Products_Call struct {
	*mock.Call
}

// Products is a helper method to define mock.On call
//   - ctx
//   - capability
func (_e *MockService_Expecter) Products(ctx interface{}, capability interface{}) *MockService_Products_Call {
	return &MockService_Products_Call{Call: _e.mock.On("Products", ctx, capability)}
}

func (_c *MockService_Products_Call) Run(run func(ctx context.Context, capability internal.CapabilityRequest)) *MockService_Products_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(internal.CapabilityRequest))
	})
	return _c
}

func (_c *MockService_Products_Call) Return(products []internal.Product, err error) *MockService_Products_Call {
	_c.Call.Return(products, err)
	return _c
}

func (_c *MockService_Products_Call) RunAndReturn(run func(ctx context.Context, capability internal.CapabilityRequest) ([]internal.Product, error)) *MockService_Products_Call {
	_c.Call.Return(run)
	return _c
}
