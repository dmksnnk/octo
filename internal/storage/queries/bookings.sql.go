// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: bookings.sql

package queries

import (
	"context"
	"database/sql"

	"github.com/dmksnnk/octo/internal"
)

const booking = `-- name: Booking :many
SELECT bookings.id, bookings.created_at, bookings.updated_at, bookings.deleted_at, bookings.product_id, bookings.availability_id, bookings.user_id, bookings.status, units.id, units.created_at, units.updated_at, units.deleted_at, units.booking_id, units.ticket
FROM bookings
LEFT JOIN units ON units.booking_id = bookings.id
WHERE bookings.id = $1
AND bookings.user_id = $2
AND bookings.deleted_at IS NULL
AND units.deleted_at IS NULL
`

type BookingParams struct {
	ID     int64
	UserID int32
}

type BookingRow struct {
	Booking Booking
	Unit    Unit
}

func (q *Queries) Booking(ctx context.Context, arg BookingParams) ([]BookingRow, error) {
	rows, err := q.db.QueryContext(ctx, booking, arg.ID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BookingRow
	for rows.Next() {
		var i BookingRow
		if err := rows.Scan(
			&i.Booking.ID,
			&i.Booking.CreatedAt,
			&i.Booking.UpdatedAt,
			&i.Booking.DeletedAt,
			&i.Booking.ProductID,
			&i.Booking.AvailabilityID,
			&i.Booking.UserID,
			&i.Booking.Status,
			&i.Unit.ID,
			&i.Unit.CreatedAt,
			&i.Unit.UpdatedAt,
			&i.Unit.DeletedAt,
			&i.Unit.BookingID,
			&i.Unit.Ticket,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const bookingForUpdate = `-- name: BookingForUpdate :many
SELECT bookings.status, units.id as unit_id
FROM bookings
JOIN units ON units.booking_id = bookings.id
WHERE bookings.id = $1
AND bookings.user_id = $2
AND bookings.deleted_at IS NULL
AND units.deleted_at IS NULL
FOR UPDATE
`

type BookingForUpdateParams struct {
	ID     int64
	UserID int32
}

type BookingForUpdateRow struct {
	Status internal.BookingStatus
	UnitID int64
}

func (q *Queries) BookingForUpdate(ctx context.Context, arg BookingForUpdateParams) ([]BookingForUpdateRow, error) {
	rows, err := q.db.QueryContext(ctx, bookingForUpdate, arg.ID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BookingForUpdateRow
	for rows.Next() {
		var i BookingForUpdateRow
		if err := rows.Scan(&i.Status, &i.UnitID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const bookingWithPrice = `-- name: BookingWithPrice :many
SELECT bookings.id, bookings.created_at, bookings.updated_at, bookings.deleted_at, bookings.product_id, bookings.availability_id, bookings.user_id, bookings.status, units.id, units.created_at, units.updated_at, units.deleted_at, units.booking_id, units.ticket, prices.id, prices.created_at, prices.updated_at, prices.deleted_at, prices.price, prices.currency, prices.product_id
FROM bookings
LEFT JOIN units ON units.booking_id = bookings.id
JOIN prices ON  prices.product_id = bookings.product_id
WHERE bookings.id = $1
AND bookings.user_id = $2
AND bookings.deleted_at IS NULL
AND units.deleted_at IS NULL
AND prices.deleted_at IS NULL
`

type BookingWithPriceParams struct {
	ID     int64
	UserID int32
}

type BookingWithPriceRow struct {
	Booking Booking
	Unit    Unit
	Price   Price
}

func (q *Queries) BookingWithPrice(ctx context.Context, arg BookingWithPriceParams) ([]BookingWithPriceRow, error) {
	rows, err := q.db.QueryContext(ctx, bookingWithPrice, arg.ID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BookingWithPriceRow
	for rows.Next() {
		var i BookingWithPriceRow
		if err := rows.Scan(
			&i.Booking.ID,
			&i.Booking.CreatedAt,
			&i.Booking.UpdatedAt,
			&i.Booking.DeletedAt,
			&i.Booking.ProductID,
			&i.Booking.AvailabilityID,
			&i.Booking.UserID,
			&i.Booking.Status,
			&i.Unit.ID,
			&i.Unit.CreatedAt,
			&i.Unit.UpdatedAt,
			&i.Unit.DeletedAt,
			&i.Unit.BookingID,
			&i.Unit.Ticket,
			&i.Price.ID,
			&i.Price.CreatedAt,
			&i.Price.UpdatedAt,
			&i.Price.DeletedAt,
			&i.Price.Price,
			&i.Price.Currency,
			&i.Price.ProductID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const confirmBooking = `-- name: ConfirmBooking :exec
UPDATE bookings
SET status = 'CONFIRMED',
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) ConfirmBooking(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, confirmBooking, id)
	return err
}

const createBooking = `-- name: CreateBooking :one
WITH reservation AS (
    UPDATE availabilities
    SET vacancies = vacancies - $1, 
        updated_at = CURRENT_TIMESTAMP
    WHERE id = $2::INTEGER
    AND product_id = $3::INTEGER
    AND deleted_at IS NULL
    AND vacancies >= $1
    RETURNING product_id, id AS availability_id
),
reserved_booking AS (
    INSERT INTO bookings (product_id, availability_id, user_id, status)
    SELECT reservation.product_id, reservation.availability_id, $4, 'RESERVED' 
    FROM reservation
    RETURNING id
),
new_units AS (
    INSERT INTO units (booking_id)
    SELECT reserved_booking.id 
    FROM reserved_booking, generate_series(1, $1) -- creating units number of rows
)
SELECT id
FROM reserved_booking
`

type CreateBookingParams struct {
	Units          int32
	AvailabilityID int32
	ProductID      int32
	UserID         int32
}

func (q *Queries) CreateBooking(ctx context.Context, arg CreateBookingParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createBooking,
		arg.Units,
		arg.AvailabilityID,
		arg.ProductID,
		arg.UserID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const setUnitTicket = `-- name: SetUnitTicket :exec
UPDATE units
SET ticket = $1,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $2
`

type SetUnitTicketParams struct {
	Ticket sql.NullString
	ID     int64
}

func (q *Queries) SetUnitTicket(ctx context.Context, arg SetUnitTicketParams) error {
	_, err := q.db.ExecContext(ctx, setUnitTicket, arg.Ticket, arg.ID)
	return err
}
