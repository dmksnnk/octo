// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: avaliabilities.sql

package queries

import (
	"context"
	"time"
)

const avalability = `-- name: Avalability :one
SELECT id, created_at, updated_at, deleted_at, product_id, local_date, vacancies FROM availabilities
WHERE product_id = $1 
AND local_date = $2
AND deleted_at IS NULL
`

type AvalabilityParams struct {
	ProductID int32
	LocalDate time.Time
}

func (q *Queries) Avalability(ctx context.Context, arg AvalabilityParams) (Availability, error) {
	row := q.db.QueryRowContext(ctx, avalability, arg.ProductID, arg.LocalDate)
	var i Availability
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProductID,
		&i.LocalDate,
		&i.Vacancies,
	)
	return i, err
}

const avalabilityRange = `-- name: AvalabilityRange :many
SELECT id, created_at, updated_at, deleted_at, product_id, local_date, vacancies FROM availabilities
WHERE product_id = $1 
AND local_date >= $2
AND local_date <= $3
AND deleted_at IS NULL
`

type AvalabilityRangeParams struct {
	ProductID      int32
	LocalDateStart time.Time
	LocalDateEnd   time.Time
}

func (q *Queries) AvalabilityRange(ctx context.Context, arg AvalabilityRangeParams) ([]Availability, error) {
	rows, err := q.db.QueryContext(ctx, avalabilityRange, arg.ProductID, arg.LocalDateStart, arg.LocalDateEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Availability
	for rows.Next() {
		var i Availability
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ProductID,
			&i.LocalDate,
			&i.Vacancies,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const avalabilityWithPrice = `-- name: AvalabilityWithPrice :one
SELECT availabilities.id, availabilities.created_at, availabilities.updated_at, availabilities.deleted_at, availabilities.product_id, availabilities.local_date, availabilities.vacancies, prices.id, prices.created_at, prices.updated_at, prices.deleted_at, prices.price, prices.currency, prices.product_id
FROM availabilities
JOIN prices ON availabilities.product_id = prices.product_id
WHERE availabilities.product_id = $1
AND availabilities.local_date = $2
AND availabilities.deleted_at IS NULL
AND prices.deleted_at IS NULL
`

type AvalabilityWithPriceParams struct {
	ProductID int32
	LocalDate time.Time
}

type AvalabilityWithPriceRow struct {
	Availability Availability
	Price        Price
}

func (q *Queries) AvalabilityWithPrice(ctx context.Context, arg AvalabilityWithPriceParams) (AvalabilityWithPriceRow, error) {
	row := q.db.QueryRowContext(ctx, avalabilityWithPrice, arg.ProductID, arg.LocalDate)
	var i AvalabilityWithPriceRow
	err := row.Scan(
		&i.Availability.ID,
		&i.Availability.CreatedAt,
		&i.Availability.UpdatedAt,
		&i.Availability.DeletedAt,
		&i.Availability.ProductID,
		&i.Availability.LocalDate,
		&i.Availability.Vacancies,
		&i.Price.ID,
		&i.Price.CreatedAt,
		&i.Price.UpdatedAt,
		&i.Price.DeletedAt,
		&i.Price.Price,
		&i.Price.Currency,
		&i.Price.ProductID,
	)
	return i, err
}

const avalabilityWithPriceRange = `-- name: AvalabilityWithPriceRange :many
SELECT availabilities.id, availabilities.created_at, availabilities.updated_at, availabilities.deleted_at, availabilities.product_id, availabilities.local_date, availabilities.vacancies, prices.id, prices.created_at, prices.updated_at, prices.deleted_at, prices.price, prices.currency, prices.product_id
FROM availabilities
JOIN prices ON availabilities.product_id = prices.product_id
WHERE availabilities.product_id = $1 
AND availabilities.local_date >= $2
AND availabilities.local_date <= $3
AND availabilities.deleted_at IS NULL
AND prices.deleted_at IS NULL
`

type AvalabilityWithPriceRangeParams struct {
	ProductID      int32
	LocalDateStart time.Time
	LocalDateEnd   time.Time
}

type AvalabilityWithPriceRangeRow struct {
	Availability Availability
	Price        Price
}

func (q *Queries) AvalabilityWithPriceRange(ctx context.Context, arg AvalabilityWithPriceRangeParams) ([]AvalabilityWithPriceRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, avalabilityWithPriceRange, arg.ProductID, arg.LocalDateStart, arg.LocalDateEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AvalabilityWithPriceRangeRow
	for rows.Next() {
		var i AvalabilityWithPriceRangeRow
		if err := rows.Scan(
			&i.Availability.ID,
			&i.Availability.CreatedAt,
			&i.Availability.UpdatedAt,
			&i.Availability.DeletedAt,
			&i.Availability.ProductID,
			&i.Availability.LocalDate,
			&i.Availability.Vacancies,
			&i.Price.ID,
			&i.Price.CreatedAt,
			&i.Price.UpdatedAt,
			&i.Price.DeletedAt,
			&i.Price.Price,
			&i.Price.Currency,
			&i.Price.ProductID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
